# Vulnerability Knowledge Base

**Source:** HackerOne, OWASP, CWE  
**Last Updated:** 2026-01-31  
**Purpose:** Quick reference for common vulnerabilities and fixes

---

## Critical Vulnerabilities (CVSS 9.0-10.0)

### RCE-001: Remote Code Execution via Command Injection

**Severity:** Critical (9.8)  
**CWE:** CWE-78  
**OWASP:** A03:2021 Injection

**Description:**
User input is passed to system shell commands without proper sanitization.

**Vulnerable Code:**
```python
# VULNERABLE - Never do this
import os
filename = request.form['filename']
os.system(f"convert {filename} -resize 100x100 output.png")
```

**Secure Code:**
```python
# SECURE - Use subprocess with array, validate input
import subprocess
from pathlib import Path

filename = request.form['filename']
# Whitelist validation
allowed_extensions = {'.png', '.jpg', '.jpeg'}
ext = Path(filename).suffix.lower()
if ext not in allowed_extensions:
    raise ValidationError("Invalid file type")

# Use array form to prevent injection
subprocess.run(
    ['convert', filename, '-resize', '100x100', 'output.png'],
    check=True,
    shell=False
)
```

**Prevention:**
1. Never use `shell=True` with user input
2. Use subprocess with array arguments
3. Whitelist validation on all inputs
4. Principle of least privilege for service accounts

---

### AUTH-001: Authentication Bypass

**Severity:** Critical (9.8)  
**CWE:** CWE-287  
**OWASP:** A07:2021 Identification and Authentication Failures

**Description:**
Attackers can bypass authentication mechanisms to access protected resources.

**Vulnerable Code:**
```python
# VULNERABLE - Broken access control
@app.route('/api/admin/users')
def get_users():
    # No authentication check!
    return User.query.all()
```

**Secure Code:**
```python
# SECURE - Proper authentication decorator
from functools import wraps
from flask import current_app, g

def require_auth(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        token = request.headers.get('Authorization')
        if not token:
            return {'error': 'Authentication required'}, 401
        
        user = verify_token(token)
        if not user:
            return {'error': 'Invalid token'}, 401
        
        g.current_user = user
        return f(*args, **kwargs)
    return decorated

@app.route('/api/admin/users')
@require_auth
@require_role('admin')
def get_users():
    return User.query.all()
```

**Prevention:**
1. Authentication on ALL protected endpoints
2. JWT with short expiration (15 min)
3. Token refresh mechanism
4. MFA for privileged operations

---

### SQLI-001: SQL Injection

**Severity:** Critical (9.8)  
**CWE:** CWE-89  
**OWASP:** A03:2021 Injection

**Description:**
User input is concatenated into SQL queries without parameterization.

**Vulnerable Code:**
```python
# VULNERABLE - String concatenation
user_id = request.args.get('id')
query = f"SELECT * FROM users WHERE id = '{user_id}'"
result = db.execute(query)
```

**Secure Code:**
```python
# SECURE - Parameterized queries
from sqlalchemy import text

user_id = request.args.get('id')
# Use parameterized queries
result = db.execute(
    text("SELECT * FROM users WHERE id = :id"),
    {'id': user_id}
)
# Or use ORM (always safe by default)
user = db.query(User).filter(User.id == user_id).first()
```

**Prevention:**
1. Always use parameterized queries
2. Use ORM for database operations
3. Whitelist validation on all inputs
4. Principle of least privilege on database user

---

## High Severity (CVSS 7.0-8.9)

### XSS-001: Cross-Site Scripting (Stored)

**Severity:** High (8.1)  
**CWE:** CWE-79  
**OWASP:** A03:2021 Injection

**Description:**
Malicious scripts are stored and executed in victims' browsers.

**Vulnerable Code:**
```python
# VULNERABLE - Raw HTML output
@app.route('/comments', methods=['POST'])
def add_comment():
    comment = request.form['comment']
    # Store without sanitization
    db.execute("INSERT INTO comments (text) VALUES (?)", comment)

@app.route('/comments')
def show_comments():
    comments = db.execute("SELECT text FROM comments").fetchall()
    return {'comments': [c['text'] for c in comments]}  # Raw output!
```

**Secure Code:**
```python
# SECURE - Output encoding
from bleach import clean

@app.route('/comments', methods=['POST'])
def add_comment():
    comment = request.form['comment']
    # Sanitize on input
    sanitized = clean(comment, tags=[], strip=True)
    db.execute("INSERT INTO comments (text) VALUES (?)", sanitized)

@app.route('/comments')
def show_comments():
    comments = db.execute("SELECT text FROM comments").fetchall()
    # Context-aware encoding (HTML)
    return {'comments': [html.escape(c['text']) for c in comments]}

# Content Security Policy header
@app.after_request
def add_csp(response):
    response.headers['Content-Security-Policy'] = (
        "default-src 'self'; "
        "script-src 'self'; "
        "style-src 'self' 'unsafe-inline'"
    )
    return response
```

**Prevention:**
1. Output encoding on all user data
2. Content Security Policy (CSP) headers
3. Input sanitization with bleach/HTMLPurifier
4. HTTPOnly and Secure flags on cookies

---

### IDOR-001: Insecure Direct Object Reference

**Severity:** High (7.5)  
**CWE:** CWE-639  
**OWASP:** A01:2021 Broken Access Control

**Description:**
Users can access resources they shouldn't by manipulating identifiers.

**Vulnerable Code:**
```python
# VULNERABLE - No ownership check
@app.route('/api/documents/<doc_id>')
def get_document(doc_id):
    # User can guess any document ID
    doc = Document.query.get(doc_id)
    return doc.to_dict()
```

**Secure Code:**
```python
# SECURE - Ownership verification
@app.route('/api/documents/<doc_id>')
@require_auth
def get_document(doc_id):
    doc = Document.query.get(doc_id)
    
    if not doc:
        return {'error': 'Not found'}, 404
    
    # Verify ownership
    if doc.tenant_id != g.current_user.tenant_id:
        return {'error': 'Access denied'}, 403
    
    # Or use declarative authorization
    authorize('read', doc)
    
    return doc.to_dict()
```

**Prevention:**
1. Verify resource ownership on every access
2. Use indirect references (hash IDs)
3. Implement RBAC with policy enforcement
4. Log all access attempts

---

### AUTH-002: JWT Weak Signing

**Severity:** High (7.5)  
**CWE:** CWE-347  
**OWASP:** A02:2021 Cryptographic Failures

**Description:**
JWT tokens are signed with weak algorithms or expose sensitive data.

**Vulnerable Code:**
```python
# VULNERABLE - Weak algorithm
import jwt

token = jwt.encode(
    {'user_id': user_id, 'role': 'admin'},
    'secret',  # HS256 with weak secret
    algorithm='HS256'
)

# Or worse - using 'none' algorithm
token = jwt.encode(payload, '', algorithm='none')
```

**Secure Code:**
```python
# SECURE - Strong algorithm, proper configuration
import jwt
from cryptography.hazmat.primitives import serialization

# Use RS256 or ES256
with open('private_key.pem', 'rb') as f:
    private_key = f.read()

token = jwt.encode(
    {
        'user_id': user_id,
        'role': 'admin',
        'tenant_id': tenant_id,
        'exp': datetime.utcnow() + timedelta(minutes=15),  # Short expiration
        'iat': datetime.utcnow(),
    },
    private_key,
    algorithm='RS256'
)

# Verify with public key
with open('public_key.pem', 'rb') as f:
    public_key = f.read()

claims = jwt.decode(
    token,
    public_key,
    algorithms=['RS256'],
    options={'verify_aud': False}  # If not using audience
)
```

**Prevention:**
1. Use RS256 or ES256, never HS256 for shared secrets
2. Short token expiration (15 min access, 7 days refresh)
3. Store tokens securely (HttpOnly cookies)
4. Implement token rotation

---

## Medium Severity (CVSS 4.0-6.9)

### INFO-001: Information Disclosure

**Severity:** Medium (5.3)  
**CWE:** CWE-200  
**OWASP:** A01:2021 Broken Access Control

**Description:**
Sensitive information is exposed through errors, headers, or API responses.

**Vulnerable Code:**
```python
# VULNERABLE - Stack traces in errors
@app.errorhandler(Exception)
def handle_error(e):
    return {
        'error': str(e),
        'traceback': traceback.format_exc()  # Exposes internals!
    }, 500
```

**Secure Code:**
```python
# SECURE - Generic error messages
@app.errorhandler(Exception)
def handle_error(e):
    # Log full details server-side
    logger.error(f"Unhandled exception: {e}", exc_info=True)
    
    # Return generic message to client
    return {
        'error': 'An unexpected error occurred'
    }, 500

# Remove sensitive headers
@app.after_request
def remove_sensitive_headers(response):
    sensitive = ['Server', 'X-Powered-By', 'X-AspNet-Version']
    for header in sensitive:
        response.headers.pop(header, None)
    return response
```

**Prevention:**
1. Generic error messages to clients
2. Detailed logging server-side
3. Remove information-disclosing headers
4. Configure production settings properly

---

### CSRF-001: Cross-Site Request Forgery

**Severity:** Medium (6.5)  
**CWE:** CWE-352  
**OWASP:** A01:2021 Broken Access Control

**Description:**
Attackers trick users into performing unwanted actions.

**Vulnerable Code:**
```python
# VULNERABLE - No CSRF protection
@app.route('/transfer', methods=['POST'])
def transfer_money():
    amount = request.form['amount']
    # Attacker can create a form on their site
    # that submits to this endpoint
    make_transfer(amount)
```

**Secure Code:**
```python
# SECURE - CSRF token validation
from flask_wtf.csrf import CSRFProtect

csrf = CSRFProtect(app)

@app.route('/transfer', methods=['POST'])
@csrf.protect  # Validates CSRF token
def transfer_money():
    amount = request.form['amount']
    make_transfer(amount)

# Include token in forms
# <input type="hidden" name="csrf_token" value="{{ csrf_token() }}"/>
```

**Prevention:**
1. CSRF tokens on all state-changing operations
2. SameSite cookie attribute
3. Origin/Referer validation
4. CAPTCHA for sensitive operations

---

### RATE-001: Lack of Rate Limiting

**Severity:** Medium (5.0)  
**CWE:** CWE-307  
**OWASP:** A07:2021 Identification and Authentication Failures

**Description:**
No rate limiting allows brute force attacks and DoS.

**Vulnerable Code:**
```python
# VULNERABLE - No rate limiting
@app.route('/login', methods=['POST'])
def login():
    username = request.form['username']
    password = request.form['password']
    # Attacker can try thousands of passwords
    return authenticate(username, password)
```

**Secure Code:**
```python
# SECURE - Rate limiting
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address

limiter = Limiter(
    app,
    key_func=get_remote_address,
    default_limits=["200 per day", "50 per hour"]
)

@app.route('/login', methods=['POST'])
@limiter.limit("5/minute")  # 5 attempts per minute
def login():
    username = request.form['username']
    password = request.form['password']
    
    # Account lockout after failures
    if failed_attempts(username) >= 5:
        lock_account(username)
        return {'error': 'Account locked'}, 429
    
    return authenticate(username, password)
```

**Prevention:**
1. Rate limiting on all endpoints
2. Exponential backoff on failures
3. Account lockout policies
4. CAPTCHA after failed attempts

---

## Quick Reference Table

| Vulnerability | Severity | Quick Fix |
|--------------|----------|-----------|
| Command Injection | Critical | Use `subprocess.run()` with array, no `shell=True` |
| SQL Injection | Critical | Parameterized queries, ORM |
| Auth Bypass | Critical | Always validate tokens, check permissions |
| Stored XSS | High | Output encoding, CSP headers |
| IDOR | High | Verify ownership, indirect references |
| Weak JWT | High | RS256 algorithm, short expiration |
| Info Disclosure | Medium | Generic errors, hide headers |
| CSRF | Medium | CSRF tokens, SameSite cookies |
| No Rate Limit | Medium | Rate limiting, account lockout |

---

## Common Misconfigurations

### 1. Debug Mode in Production

```python
# WRONG
app.run(debug=True)

# CORRECT
if __name__ == '__main__':
    app.run(debug=False, host='0.0.0.0', port=8000)
```

### 2. Verbose Error Messages

```python
# WRONG - Exposes stack trace
return str(e), 500

# CORRECT - Generic message
logger.error(e)
return "Internal server error", 500
```

### 3. Insecure Headers

```python
# WRONG - Information disclosure
response.headers['X-Powered-By'] = 'Express'

# CORRECT - Remove or obfuscate
response.headers.pop('X-Powered-By', None)
```

### 4. Default Credentials

```python
# WRONG - Hardcoded credentials
password = "admin123"

# CORRECT - Environment variables
import os
password = os.environ['ADMIN_PASSWORD']
```

---

## Testing Checklist

### Before Deployment

- [ ] SAST scan passed (Bandit, Semgrep)
- [ ] Dependency scan passed (Snyk, pip-audit)
- [ ] Secret scan passed (TruffleHog)
- [ ] DAST scan passed (ZAP)
- [ ] No critical/high vulnerabilities
- [ ] Authentication on all protected endpoints
- [ ] Authorization verified (IDOR tests)
- [ ] Input validation on all endpoints
- [ ] Output encoding implemented
- [ ] Rate limiting configured
- [ ] CSRF protection enabled
- [ ] Security headers present
- [ ] Error handling doesn't leak info
- [ ] Logging implemented
- [ ] No hardcoded secrets
- [ ] HTTPS configured
- [ ] CORS configured correctly
